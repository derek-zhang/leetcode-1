//（1）对于第1行，如果有障碍，则障碍处开始往后，方法数均为0，否则为1；
//（2）对于第1列，如果有障碍，则障碍处开始往下，方法数均为0，否则为1；
//（3）到达A[i][j]，如果A[i][j]有障碍，则方法数为0，否则，可以从A[i-1][j]到达A[i][j]，也可以从A[i][j-1]到达A[i][j]，可用的方法有A[i-1][j]+A[i][j-1]种。
int uniquePathsWithObstacles(vector<vector<int> > &obstacleGrid)
{
  int m = obstacleGrid.size();
	if(m == 0)
		return 0;
	int n = obstacleGrid[0].size();
	if(n == 0)
		return 0;
	int dp[m][n];
	bool isBlocked = false;
	for(int c = 0; c < n; ++c)
	{
		if(isBlocked == false && obstacleGrid[0][c] == 1)
			isBlocked = true;
		if(isBlocked == false)
			dp[0][c] = 1;
		else
			dp[0][c] = 0;
	}
	isBlocked = false;
	for(int r = 0; r < m; ++r)
	{
		if(isBlocked == false && obstacleGrid[r][0] == 1)
			isBlocked = true;
		if(isBlocked == false)
			dp[r][0] = 1;
		else
			dp[r][0] = 0;
	}
	for (int r = 1; r < m; ++r)
		for (int c = 1; c < n; ++c)
		{
			if(obstacleGrid[r][c] == 0)
				dp[r][c] = dp[r - 1][c] + dp[r][c - 1];
			else 
				dp[r][c] = 0;
		}
	return dp[m - 1][n - 1];
}
