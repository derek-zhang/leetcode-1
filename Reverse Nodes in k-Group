problem：
Given a linked list, reverse the nodes of a linked list k at a time and return its modified list.

If the number of nodes is not a multiple of k then left-out nodes in the end should remain as it is.

You may not alter the values in the nodes, only nodes itself may be changed.

Only constant memory is allowed.

For example,
Given this linked list: 1->2->3->4->5

For k = 2, you should return: 2->1->4->3->5

For k = 3, you should return: 3->2->1->4->5
-----------------------------------------------------------------------------
solution：
//这题要求在原链上修改，也就是够k个组成的部分进行reverse，不够的则保持
//用指针的指针绑定头结点，然后依次修改链表，最后返回头结点
ListNode *reverseKGroup(ListNode *head, int k)
{
  if(k < 2)
		return head;
	ListNode **pStr = &head;
	while(*pStr)
	{
		ListNode *pEnd = *pStr;
		for(int i = 1; pEnd && i < k; i++)
			pEnd = pEnd->next;
		if(pEnd)  //reverse the segment
		{
			ListNode *pSubTail = *pStr;
			for(int j = 1; j < k; j++)
			{
				ListNode *pNext = pSubTail->next;
				pSubTail->next = pNext->next;
				pNext->next = *pStr;
				*pStr = pNext;
			}
			pStr = &(pSubTail->next);
		}
		else  //nodes that should not be changed
		{
			break;
		}
	}
	return head;
}
